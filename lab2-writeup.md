# Lab 1 Writeup: Arthi Kumar and Carly Romig

## Question 1 - Grammars: Synthetic Examples

### (a) Describe the language defined by the following grammar:
		S ::= ABA
		A ::= a|aA
		B ::= ε|bBc|BB 
![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/image1.jpg)

This language uses grammars to create various combinations of strings, as shown by several strings created by ASTs in the above image. above that generate a variety of strings
With this specific language,a string can be infinitely long but will always start with "a" and end with "a." For example, "bab" is null in this language since S always derives to ABA. Since A can only go to a or aA, we know that each string cannot result with a starting expression of b. This is exhibited in Figure 1.3. It can also be shown that for every small b that you derive, there will be a small c as well. When calling B, the onyl option to deriving to a small b is to have a small c in the string. This is shown in Figure 1.3 and Figure 1.4. Each string that take derives a little b has a little c in their resulting strings.

### (b) Consider the following grammar:
		S ::= AaBb
		A ::= Ab|b
		B ::= aB|a
### Which of the following sentences are in the language generated by this grammar? For the sentences that are described by this grammar, demonstrate that they are by giving **derivations**. 
#### 1.baab
"baab" is a string in this language because it can be derived from a version of the AST through left associative steps:
		
		S-> AbaBb   [by S->AaBb]
		 -> baBb    [by A->b]
		 -> baab    [by B->a]
#### 4.bbaab
"bbaab" is a string in this language because it can be derived from a version of the AST through left associative steps:
		
		S -> AaBb    [by S->AaBb]
		  -> AbaBb   [by A->Ab]
		  -> bbaBb   [by A->b]
		  -> bbaab   [by B->a]

### (c) Consider the following grammar:
		S ::= aScB|A|b
		A ::= cA|c
		B ::= d|A
### Which of the following sentences are in the language generated by this grammar? For the sentences that are described by this grammar, demonstrate that they are by giving **parse trees**.
 
 #1 and #5 are strings that are generated by the grammar. #2 can't be in the language because B only results in d, not bd. The only way to get bd would be to call S again, but this couldn't work because bd can never be next to each other. #3 doesn't work because you'd have to call AScB twice, which would make the string impossible with the set of grammars. #4 also can't be generated by the language. Since there's three variables in this string, its impossible to get to this result because there will always be atleast four variables in your string, since s->aScB.

		1.abcd
![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/image2.jpg)

		5.accc
![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/image3.jpg)

### (d) Consider the following grammar:
		A ::= a|b|A+A
### Show that this grammar is ambiguous.
![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/image4.jpg)
This grammar results in more than one parse tree for one string. For example, if you take the string "a+b+a," it is possibile that the tree can be left and right associative, as shown in the example. This means the grammar is ambiguous, since there's more than one way to get to your output.

### (e) Let us ascribe a semantics to the syntactic objects A specified in the above grammar from part D. In particular, let us write
		A⇓n
### for the judgment form that should mean A has a total n a symbols where n is the meta- variable for natural numbers. Define this judgment form via a set of inference rules. You may rely upon arithmetic operators over natural numbers. Hint: There should be one inference rule for each production of the non-terminal A (called a syntax-directed judgment form).

The image below displays the inference rules we developed for A ::= a|b|A+A. Since we are considering how many **a**s are mentioned in a string, we must calculate how many **a**s can be found in each case:

![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/inference%20rule.jpg)
By first using the case of "A+A", we define the first A to be x, and the second A to be y. Thus, assuming they are different variables, the number of times a shows up can be added together, as shown by the second line(x+y ⇓ n+m). We can then find the amount of **a**s using this method. Since both **a** and **b** are also cases in our grammar, we also put them into account in our set of inference rules. Since there are no operations that are included in either variable, both **a** and **b** are axioms.Thus we simply use their cases to exemplify **n** times **a** appears in a string. For the simple variable **a**, this would be 1 time, and for **b** it would evidently be 0 since no **a** variable ever occurs in **b**. 

![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/example.jpg)
The image above can demonstrate this idea. It takes "a+b," substituing a and b for x and y and then solves A⇓n using the inference rules we developed for the language. Since theres one **a** and one **b**, the result is 0 + 1, meaning that theres one occurence of a in the string.
![alt text](https://github.com/icarly10910/lab2-teamGreenBean/blob/master/images/example2.jpg)
In this example, we take an input string of "a+a+a" and display that the resulting value would be 3. We do this by using our defined set of inference rules to display that you can get a+a+a⇓3 in two steps. The first step is taking the first string a as x, and the second as y. after solving for the first part of the problem, "a+a", we then take this argument as x, and the last "a" as y. We then use the same inference rules to solve again, resulting in a+a+a⇓3.


## Question 2 - Grammars: Understanding a Language

### (a) Consider the following two grammars for expressions e. In both grammars, operator and operand are the same; you do not need to know their productions for this question.

1.		e ::= operand | e operator operand

2.		e ::= operand esuffix
		esuffix ::= operator operand esuffix | ε
#### 		i. Intuitively describe the expressions generated by the two grammars.
####		ii. Do these grammars generate the same or different expressions? Explain. 

### (b) Write a Scala expression to determine if ‘−’ has higher precedence than ‘<<’ or vice versa. Make sure that you are checking for precedence in your expression and not for left or right associativity. Use parentheses to indicate the possible abstract syntax trees, and then show the evaluation of the possible expressions. Finally, explain how you arrived at the relative precedence of ‘−’ and ‘<<’ based on the output that you saw in the Scala interpreter.

### (c) Give a BNF grammar for floating point numbers that are made up of a fraction (e.g., 5.6 or 3.123 or -2.5) followed by an optional exponent (e.g., E10 or E-10). The expo- nent, if it exists, is the letter ‘E’ followed by an integer. For example, the following are floating point numbers: 3.5E3, 3.123E30, -2.5E2, -2.5E-2, and 3.5. The following are not examples of floating point numbers: 3.E3, E3, and 3.0E4.5.

### More precisely, our floating point numbers must have a decimal point, do not have leading zeros, can have any number of trailing zeros, non-zero exponents (if it exists), must have non-zero fraction to have an exponent, and cannot have a ‘-’ in front of a zero number. The exponent cannot have leading zeros.

### For this exercise, let us assume that the tokens are characters in the following alphabet Σ:

		Σ = {0,1,2,3,4,5,6,7,8,9,E,-,.}
### Your grammar should be completely defined (i.e., it should not count on a non-terminal that it does not itself define).
